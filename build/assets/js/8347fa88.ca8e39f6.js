"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[8752],{8547:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var o=t(6070),r=t(1582);const s={title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"},i=void 0,a={id:"build-on-morph/code-examples/bridge-between-morph-and-ethereum",title:"Bridge between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!",source:"@site/docs/build-on-morph/code-examples/2-bridge-between-morph-and-ethereum.md",sourceDirName:"build-on-morph/code-examples",slug:"/build-on-morph/code-examples/bridge-between-morph-and-ethereum",permalink:"/docs/build-on-morph/code-examples/bridge-between-morph-and-ethereum",draft:!1,unlisted:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/build-on-morph/code-examples/2-bridge-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimistic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimistic zk-rollup solution. Try it now!"}},d={},c=[{value:"Bridge an ERC20 through custom gateway",id:"bridge-an-erc20-through-custom-gateway",level:2},{value:"Step 1: Launch a token on Holesky",id:"step-1-launch-a-token-on-holesky",level:2},{value:"Step 2: Launch the counterpart token on Morph Holesky testnet",id:"step-2-launch-the-counterpart-token-on-morph-holesky-testnet",level:2},{value:"Step 3: Add the token to the Morph Bridge",id:"step-3-add-the-token-to-the-morph-bridge",level:2},{value:"Step 4: Deposit tokens",id:"step-4-deposit-tokens",level:2},{value:"Step 5: Withdraw tokens",id:"step-5-withdraw-tokens",level:2},{value:"Send messages between Morph and Ethereum",id:"send-messages-between-morph-and-ethereum",level:2},{value:"Deploying the Contracts",id:"deploying-the-contracts",level:2},{value:"Target Smart Contract",id:"target-smart-contract",level:3},{value:"Operator Smart Contract",id:"operator-smart-contract",level:3},{value:"Calling a Cross-chain Function",id:"calling-a-cross-chain-function",level:2},{value:"Relay the Message when sending from L2 to L1",id:"relay-the-message-when-sending-from-l2-to-l1",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"bridge-an-erc20-through-custom-gateway",children:"Bridge an ERC20 through custom gateway"}),"\n",(0,o.jsx)(n.h2,{id:"step-1-launch-a-token-on-holesky",children:"Step 1: Launch a token on Holesky"}),"\n",(0,o.jsx)(n.p,{children:"First, we need a token to bridge. There is no need for a particular ERC20 implementation in order for a token to be compatible with L2. If you already have a token, feel free to skip this step. If you want to deploy a new token, use the following contract of a simple ERC20 token that mints 1 million tokens to the deployer when launched."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\n\ncontract L1Token is ERC20 {\n  constructor() ERC20("My Token L1", "MTL1") {\n    _mint(msg.sender, 1_000_000 ether);\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"step-2-launch-the-counterpart-token-on-morph-holesky-testnet",children:"Step 2: Launch the counterpart token on Morph Holesky testnet"}),"\n",(0,o.jsx)(n.p,{children:"Next, you'll launch a counterpart to this token on Morph, which will represent the original token on Holesky. This token can implement custom logic to match that of the L1 token or even add additional features beyond those of the L1 token."}),"\n",(0,o.jsx)(n.p,{children:"For this to work:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The token must implement the ",(0,o.jsx)(n.code,{children:"IMorphStandardERC20"})," interface in order to be compatible with the bridge."]}),"\n",(0,o.jsxs)(n.li,{children:["The contract should provide the gateway address and the counterpart token addresses (the L1 token we just launched) under the ",(0,o.jsx)(n.code,{children:"gateway()"})," and ",(0,o.jsx)(n.code,{children:"counterpart()"})," functions. It should also allow the L2 gateway to call the token ",(0,o.jsx)(n.code,{children:"mint()"})," and ",(0,o.jsx)(n.code,{children:"burn()"})," functions, which are called when a token is deposited and withdrawn."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The following is a complete example of a token compatible with the bridge. To the constructor, you will pass the official Morph Custom Gateway address (",(0,o.jsx)(n.code,{children:"0x058dec71E53079F9ED053F3a0bBca877F6f3eAcf"}),") and the address of the token launched on Holesky."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport "@openzeppelin/contracts/token/ERC20/ERC20.sol";\nimport "@Morph-tech/contracts@0.1.0/libraries/token/IMorphERC20Extension.sol";\n\ncontract L2Token is ERC20, IMorphERC20Extension {\n  // We store the gateway and the L1 token address to provide the gateway() and counterpart() functions which are needed from the Morph Standard ERC20 interface\n  address _gateway;\n  address _counterpart;\n\n  // In the constructor we pass as parameter the Custom L2 Gateway and the L1 token address as parameters\n  constructor(address gateway_, address counterpart_) ERC20("My Token L2", "MTL2") {\n    _gateway = gateway_;\n    _counterpart = counterpart_;\n  }\n\n  function gateway() public view returns (address) {\n    return _gateway;\n  }\n\n  function counterpart() external view returns (address) {\n    return _counterpart;\n  }\n\n  // We allow minting only to the Gateway so it can mint new tokens when bridged from L1\n  function transferAndCall(address receiver, uint256 amount, bytes calldata data) external returns (bool success) {\n    transfer(receiver, amount);\n    data;\n    return true;\n  }\n\n  // We allow minting only to the Gateway so it can mint new tokens when bridged from L1\n  function mint(address _to, uint256 _amount) external onlyGateway {\n    _mint(_to, _amount);\n  }\n\n  // Similarly to minting, the Gateway is able to burn tokens when bridged from L2 to L1\n  function burn(address _from, uint256 _amount) external onlyGateway {\n    _burn(_from, _amount);\n  }\n\n  modifier onlyGateway() {\n    require(gateway() == _msgSender(), "Ownable: caller is not the gateway");\n    _;\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"step-3-add-the-token-to-the-morph-bridge",children:"Step 3: Add the token to the Morph Bridge"}),"\n",(0,o.jsxs)(n.p,{children:["You need to contact the Morph team to add the token to ",(0,o.jsx)(n.code,{children:"L2CustomERC20Gateway"})," contract in Morph and ",(0,o.jsx)(n.code,{children:"L1CustomERC20Gateway"})," contract in L1. In addition, follow the instructions on the ",(0,o.jsx)(n.a,{href:"https://github.com/Morph-tech/token-list",children:"token lists"})," repository to add your token to the Morph canonical bridge frontend."]}),"\n",(0,o.jsx)(n.h2,{id:"step-4-deposit-tokens",children:"Step 4: Deposit tokens"}),"\n",(0,o.jsxs)(n.p,{children:["Once your token has been approved by the Morph team, you should be able to deposit tokens from L1. To do so, you must first approve the ",(0,o.jsx)(n.code,{children:"L1CustomGateway"})," contract address on Holesky (",(0,o.jsx)(n.code,{children:"0x31C994F2017E71b82fd4D8118F140c81215bbb37"}),"). Then, deposit tokens by calling the ",(0,o.jsx)(n.code,{children:"depositERC20"})," function from the ",(0,o.jsx)(n.code,{children:"L1CustomGateway"})," contract. This can be done using ",(0,o.jsx)(n.a,{href:"https://Morph.io/bridge",children:"our bridge UI"}),", ",(0,o.jsx)(n.a,{href:"https://Holesky.etherscan.io/address/0x31C994F2017E71b82fd4D8118F140c81215bbb37#writeProxyContract",children:"Etherscan Holesky"}),", or a smart contract."]}),"\n",(0,o.jsx)(n.h2,{id:"step-5-withdraw-tokens",children:"Step 5: Withdraw tokens"}),"\n",(0,o.jsxs)(n.p,{children:["You will follow similar steps to send tokens back from L2 to L1. First, approve the ",(0,o.jsx)(n.code,{children:"L2CustomGateway"})," address (",(0,o.jsx)(n.code,{children:"0x058dec71E53079F9ED053F3a0bBca877F6f3eAcf"}),") and then withdraw the tokens calling the ",(0,o.jsx)(n.code,{children:"withdrawERC20"})," from the ",(0,o.jsx)(n.code,{children:"L2CustomGateway"})," contract."]}),"\n",(0,o.jsx)(n.h2,{id:"send-messages-between-morph-and-ethereum",children:"Send messages between Morph and Ethereum"}),"\n",(0,o.jsx)(n.h2,{id:"deploying-the-contracts",children:"Deploying the Contracts"}),"\n",(0,o.jsx)(n.h3,{id:"target-smart-contract",children:"Target Smart Contract"}),"\n",(0,o.jsx)(n.p,{children:"Let\u2019s start by deploying the target smart contract. We will use the Greeter contract for this\nexample, but you can use any other contract. Deploy it to either Holesky or Morph. On Morph, L1\nand L2 use the same API, so it\u2019s up to you."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This Greeter contract will be interacted with through the MorphMessenger across the bridge\ncontract Greeter {\n  string public greeting = "Hello World!";\n\n  // This function will be called by executeFunctionCrosschain on the Operator Smart Contract\n  function setGreeting(string memory greeting_) public {\n    greeting = greeting_;\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We will now execute ",(0,o.jsx)(n.code,{children:"setGreeting"})," in a cross-chain way."]}),"\n",(0,o.jsx)(n.h3,{id:"operator-smart-contract",children:"Operator Smart Contract"}),"\n",(0,o.jsxs)(n.p,{children:["Switch to the other chain and deploy the ",(0,o.jsx)(n.code,{children:"GreeterOperator"}),". So, if you deployed the ",(0,o.jsx)(n.code,{children:"Greeter"})," contract on L1, deploy the ",(0,o.jsx)(n.code,{children:"GreeterOperator"})," on L2 or vice versa."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// The Morph Messenger interface is the same on both L1 and L2, it allows sending cross-chain transactions\n// Let\'s import it directly from the Morph Contracts library\nimport "@Morph-tech/contracts@0.1.0/libraries/IMorphMessenger.sol";\n\n// The GreeterOperator is capable of executing the Greeter function through the bridge\ncontract GreeterOperator {\n  // This function will execute setGreeting on the Greeter contract\n  function executeFunctionCrosschain(\n    address MorphMessengerAddress,\n    address targetAddress,\n    uint256 value,\n    string memory greeting,\n    uint32 gasLimit\n  ) public payable {\n    IMorphMessenger MorphMessenger = IMorphMessenger(MorphMessengerAddress);\n    // sendMessage is able to execute any function by encoding the abi using the encodeWithSignature function\n    MorphMessenger.sendMessage{ value: msg.value }(\n      targetAddress,\n      value,\n      abi.encodeWithSignature("setGreeting(string)", greeting),\n      gasLimit,\n      msg.sender\n    );\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"calling-a-cross-chain-function",children:"Calling a Cross-chain Function"}),"\n",(0,o.jsxs)(n.p,{children:["We pass the message by executing ",(0,o.jsx)(n.code,{children:"executeFunctionCrosschain"})," and passing the following parameters:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"MorphMessengerAddress"}),": This will depend on where you deployed the ",(0,o.jsx)(n.code,{children:"GreeterOperator"})," contract.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If you deployed it on Holesky use ",(0,o.jsx)(n.code,{children:"0x50c7d3e7f7c656493D1D76aaa1a836CedfCBB16A"}),". If you deployed on Morph Holesky use ",(0,o.jsx)(n.code,{children:"0xBa50f5340FB9F3Bd074bD638c9BE13eCB36E603d"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"targetAddress"}),": The address of the ",(0,o.jsx)(n.code,{children:"Greeter"})," contract on the opposite chain."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"value"}),": In this case, it is ",(0,o.jsx)(n.code,{children:"0"})," because the ",(0,o.jsx)(n.code,{children:"setGreeting"}),"is not payable."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"greeting"}),": This is the parameter that will be sent through the message. Try passing ",(0,o.jsx)(n.code,{children:"\u201cThis message was cross-chain!\u201d"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"gasLimit"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If you are sending the message from L1 to L2, around ",(0,o.jsx)(n.code,{children:"1000000"})," gas limit should be more than enough. That said, if you set this too high, and ",(0,o.jsx)(n.code,{children:"msg.value"})," doesn't cover ",(0,o.jsx)(n.code,{children:"gasLimit"})," * ",(0,o.jsx)(n.code,{children:"baseFee"}),", the transaction will revert. If ",(0,o.jsx)(n.code,{children:"msg.value"})," is greater than the gas fee, the unused portion will be refunded."]}),"\n",(0,o.jsxs)(n.li,{children:["If you are sending the message from L2 to L1, pass ",(0,o.jsx)(n.code,{children:"0"}),", as the transaction will be completed by executing an additional transaction on L1."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"relay-the-message-when-sending-from-l2-to-l1",children:"Relay the Message when sending from L2 to L1"}),"\n",(0,o.jsxs)(n.p,{children:['When a transaction is passed from L2 to L1, an additional "execute withdrawal transaction" must be sent on L1. To do this, you must call ',(0,o.jsx)(n.code,{children:"relayMessageWithProof"})," on the L1 Morph Messenger\ncontract from an EOA wallet."]}),"\n",(0,o.jsxs)(n.p,{children:["You can do this directly on ",(0,o.jsx)(n.a,{href:"https://Holesky.etherscan.io/address/0x50c7d3e7f7c656493d1d76aaa1a836cedfcbb16a#writeProxyContract#F3",children:"Etherscan Holesky"}),".\nTo do so, you will need to pass a Merkle inclusion proof for the bridged transaction and other parameters. You'll query these using the Morph Bridge API."]}),"\n","\n",(0,o.jsx)(n.p,{children:"We're finalizing the API specifics, but for now, fetch or curl the following endpoint:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'curl "https://Holesky-api-bridge.Morph.io/api/claimable?page_size=10&page=1&address=GREETER_OPERATOR_ADDRESS_ON_L2"\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsx)(n.p,{children:"This API was made for our Bridge UI. It is not yet finalized and may change in the future. We will update this guide\nwhen the API is finalized."})}),"\n",(0,o.jsx)(n.admonition,{title:"Anyone can execute your message",type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"relayMessageWithProof"})," is fully permissionless, so anyone can call it on your behalf if they're willing to pay the L1\ngas fees. This feature allows for additional support infrastructure, including tooling to automate this process for\napplications and users."]})}),"\n",(0,o.jsxs)(n.p,{children:["After executing and confirming the transaction on both L1 and L2, the new state of ",(0,o.jsx)(n.code,{children:"greeting"})," on the ",(0,o.jsx)(n.code,{children:"Greeter"})," contract should be ",(0,o.jsx)(n.code,{children:"\u201cThis message was cross-chain!\u201d"}),". Sending a message from one chain to the other should take around 20 minutes after the transactions are confirmed on the origin chain."]}),"\n",(0,o.jsx)(n.p,{children:"Congratulations, you now executed a transaction from one chain to the other using our native bridge!"})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1582:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(758);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);